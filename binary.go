//
// code generated by binary-go.
//
// DO NOT EDIT!

package geolite

import (
	"bytes"
	"compress/gzip"
	"errors"
	"log"
	"strconv"
	"strings"
)

var data = map[string][]string{
	"GeoLite2-City.mmdb": []string{
		d9e4a60aaf816febd5d102a3a0b137fcb7e06040f, d6425770c9f2b9de98d7235d20073252c6ecc7753, d2ca89a081c835d2adf4dd2068d7538ed8d0166ec, dabd2c51d7b0e599215cce318f91a2a83f80cd079,
	},
}

var size = map[string]int{
	"GeoLite2-City.mmdb": 65865934,
}

// Bytes to retrieve file data
func Bytes(filename string) ([]byte, error) {
	var r bytes.Buffer
	defer r.Truncate(0)
	part, ok := data[filename]
	if !ok {
		return nil, errors.New("file does not exist")
	}
	size, ok := size[filename]
	if !ok {
		return nil, errors.New("could not find file size information")
	}
	cont := strings.Join(part, "")
	arry := strings.Split(cont, " ")
	for _, v := range arry {
		n, err := strconv.Atoi(v)
		if err != nil {
			return nil, err
		}
		b := byte(n)
		r.WriteByte(b)
	}
	data := make([]byte, size)
	bytr := bytes.NewReader(r.Bytes())
	gz, err := gzip.NewReader(bytr)
	if err != nil {
		return nil, err
	}
	defer gz.Close()
	if _, err := gz.Read(data); err != nil {
		return nil, err
	}
	return data, nil
}

// MustBytes to read bytes data from file
func MustBytes(filename string) []byte {
	b, err := Bytes(filename)
	if err != nil {
		log.Panic(err)
	}
	return b
}
