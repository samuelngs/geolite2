//
// code generated by binary-go.
//
// DO NOT EDIT!

package geolite

import (
	"bytes"
	"compress/gzip"
	"errors"
	"io"
	"log"
	"strings"
)

var data = map[string][]string{
	"GeoLite2-City.mmdb": []string{
		d3795705a69e1d5ceed68c4aacfce8d57a6241456, d7ed4099e97b4e01efee2c5c9f6d58f59fe88ebd6, da5cc1d5162cf26f2cd5456e95dd749c8243428cd, d9db89ed3329a1e2e9788b09b6553b0c4db79f8a8, dcbd460f77c70f94eba5976b49409fb2218fa10af,
	},
}

// Bytes to retrieve file data
func Bytes(filename string) (b []byte, e error) {
	var r bytes.Buffer
	defer r.Truncate(0)
	part, ok := data[filename]
	if !ok {
		return nil, errors.New("file does not exist")
	}
	ch := make(chan []byte, 1)
	go func() {
		cont := strings.Join(part, "")
		data := []byte(cont)
		gz, err := gzip.NewReader(bytes.NewBuffer(data))
		if err != nil {
			e = err
			ch <- nil
			return
		}
		var buf bytes.Buffer
		if _, err = io.Copy(&buf, gz); err != nil {
			e = err
			ch <- nil
			return
		}
		if err := gz.Close(); err != nil {
			e = err
			ch <- nil
			return
		}
		ch <- buf.Bytes()
	}()
	return <-ch, nil
}

// MustBytes to read bytes data from file
func MustBytes(filename string) []byte {
	b, err := Bytes(filename)
	if err != nil {
		log.Panic(err)
	}
	return b
}
